package gopscreen

import (
	"bufio"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/hophouse/gop/gopchromedp"
	"github.com/hophouse/gop/utils"
	"github.com/hophouse/gop/utils/logger"
)

func RunScreenCmd(reader *os.File, proxy string, concurrency int, timeout int, delay int, cookie string, doNotAppendSlash bool) {
	// Create a specific log file for the screenshots
	err := os.Mkdir(filepath.Join(logger.CurrentLogDirectory, "screenshots"), 0o755)
	if err != nil {
		logger.Println("Error could not create the \"screenshots\" folder")
	}

	err = os.Mkdir(filepath.Join(logger.CurrentLogDirectory, "json"), 0o755)
	if err != nil {
		logger.Println("Error could not create the \"json\" folder")
	}

	err = os.Mkdir(filepath.Join(logger.CurrentLogDirectory, "html"), 0o755)
	if err != nil {
		logger.Println("Error could not create the \"html\" folder")
	}

	// Create HTML index page
	f, err := os.Create(filepath.Join(logger.CurrentLogDirectory, "./index.html"))
	if err != nil {
		logger.Println(err)
	}
	defer f.Close()

	_, err = f.WriteString(gopchromedp.ExportHTMLPage())
	if err != nil {
		logger.Println(err)
	}

	inputChan := make(chan *url.URL, concurrency)
	workerChan := make(chan bool)
	outputChan := make(chan gopchromedp.Item)

	begin := time.Now()

	// bars
	progressBars := utils.InitWaitGroupBar()
	screenshotBar := progressBars.AddBar("Screenshot", true)

	// Retrieve URLs
	scanner := bufio.NewScanner(reader)
	urls := []*url.URL{}
	for scanner.Scan() {
		itemString := scanner.Text()
		item, err := url.Parse(itemString)
		if err != nil {
			logger.Printf("[Error] %s\n", err)
			continue
		}

		if doNotAppendSlash {
			urls = append(urls, item)
			screenshotBar.AddAndIncrementTotal(2)
		} else {
			if !strings.HasSuffix(item.String(), "/") {
				item, _ = url.Parse(itemString + "/")
				urls = append(urls, item)
			}
		}
	}
	screenshotBar.SetTotal(len(urls))

	// Screenshot list
	screenshotList := []gopchromedp.Item{}

	// Launch the workers that will process the outputs
	go func(outputChan chan gopchromedp.Item, workerChan chan bool, screenshotList *[]gopchromedp.Item) {
		for item := range outputChan {
			// consume output
			*screenshotList = append(*screenshotList, item)
		}
		workerChan <- true
	}(outputChan, workerChan, &screenshotList)

	// Launch the workers
	for i := 0; i < concurrency; i++ {
		go func(inputChan chan *url.URL, workerChan chan bool, outputChan chan gopchromedp.Item) {
			for requestURL := range inputChan {
				item := gopchromedp.NewItem(requestURL.String())

				logger.Fprintf(logger.Writer(), "[+] Taking screenshot for %s\n", requestURL)
				// Go make the screenshot
				gopchromedp.TakeScreenShot(&item, filepath.Join(logger.CurrentLogDirectory, "screenshots"), proxy, cookie, timeout)

				logger.Fprintf(logger.Writer(), "[+] Taking HTML code for %s\n", requestURL)
				// Go take the HTML code
				gopchromedp.GetHTMLCode(&item, requestURL.String(), filepath.Join(logger.CurrentLogDirectory, "html"), proxy, cookie, timeout)

				// Add screenshot to list
				outputChan <- item
				screenshotBar.Done()

				time.Sleep(time.Duration(delay))
			}
			workerChan <- true
		}(inputChan, workerChan, outputChan)
	}

	// Fill the input channel with entries
	for _, url := range urls {
		screenshotBar.AddAndIncrementTotal(1)
		inputChan <- url
	}
	close(inputChan)

	// Wait for workers to finish
	for i := 0; i < concurrency; i++ {
		<-workerChan
	}
	close(outputChan)

	// Wait for the output chan to finish processing outputs
	<-workerChan

	// Export loaded resources
	f, err = os.Create(filepath.Join(logger.CurrentLogDirectory, "./loaded_resources.txt"))
	if err != nil {
		logger.Println(err)
	}
	defer f.Close()
	_, err = f.WriteString(gopchromedp.ExportLoadedResources(screenshotList))
	if err != nil {
		logger.Println(err)
	}

	// Export data as JSON
	itemsJSON := gopchromedp.ExportItemsToJSON(screenshotList)
	f, err = os.Create(filepath.Join(logger.CurrentLogDirectory, "./json/data.json"))
	if err != nil {
		logger.Println(err)
	}
	defer f.Close()

	_, err = f.WriteString(itemsJSON)
	if err != nil {
		logger.Println(err)
	}

	// Export data as JSON in JavaScript object
	f, err = os.Create(filepath.Join(logger.CurrentLogDirectory, "./json/data.json.js"))
	if err != nil {
		logger.Println(err)
	}
	defer f.Close()
	_, err = f.WriteString("const itemsJSON = " + itemsJSON)
	if err != nil {
		logger.Println(err)
	}

	progressBars.Wait()

	end := time.Now()
	logger.Printf("[+] Execution time : %s\n", end.Sub(begin))

	/*
		// Scanner to read file
		// scanner := bufio.NewScanner(reader)
		for scanner.Scan() {
			url, err := url.Parse(scanner.Text())
			if err != nil {
				logger.Println(err)
				continue
			}

			utils.ScreenshotBar.Add(1)
			go func(sl *[]gopchromedp.Item) {
				//defer utils.ScreenshotBar.Done()
				concurrencyChan <- struct{}{}

				// Take screenshot
				gopchromedp.TakeScreenShot(url.String(), "", cookie, proxy)

				// Add screenshot to list
				*sl = append(*sl, gopchromedp.Item{
					Url:           url.String(),
					RequestStatus: "Uknown",
				})

				<-concurrencyChan
			}(&screenshotList)

			time.Sleep(time.Duration(delay) * time.Second)
		}
		if err := scanner.Err(); err != nil {
			logger.Fatal(err)
		}

		progressBars.Wait()
	*/
}
