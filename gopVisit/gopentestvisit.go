package gopvisit

import (
	"bufio"
	"crypto/tls"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/hophouse/gop/utils/logger"
)

var (
	wg sync.WaitGroup
)

func RunVisitCmd(reader *os.File, proxy string) {
	begin := time.Now()

	// Create HTTP Client
	client := newClient(proxy)

	// Scanner to read file
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		url, err := url.Parse(scanner.Text())
		if err != nil {
			logger.Println(err)
			logger.Printf("[Error] %s\n", url.String())
			continue
		}

		wg.Add(1)
		go func() {
			resp, title, redirect, authentication, err := visitUrl(client, url.String())
			if err != nil {
				logger.Printf("[!] Error with URL : %s, %s", url, err)
				return
			}
			output := fmt.Sprintf("[%s][%s][%s][%s] %s\n", resp.Status, title, redirect, authentication, url)
			logger.Print(output)
		}()
	}
	if err := scanner.Err(); err != nil {
		logger.Fatal(err)
	}

	wg.Wait()
	end := time.Now()
	fmt.Printf("\n[+] Execution time : %s\n", end.Sub(begin))
}

func newClient(proxy string) *http.Client {
	tr := http.DefaultTransport.(*http.Transport).Clone()
	tr.DisableKeepAlives = true
	tr.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	// Disable HTTP/2.
	tr.TLSNextProto = make(map[string]func(authority string, c *tls.Conn) http.RoundTripper)

	if proxy != "" {
		proxyUrl, err := url.Parse(proxy)
		if err != nil {
			logger.Fatal(err)
		}
		tr.Proxy = http.ProxyURL(proxyUrl)
	}

	client := &http.Client{Transport: tr}
	client.Timeout = 10 * time.Second
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		return http.ErrUseLastResponse
	}

	return client
}

func visitUrl(client *http.Client, url string) (*http.Response, string, string, string, error) {
	defer wg.Done()
	title := ""
	redirect := ""
	authentication := ""

	resp, err := client.Get(url)
	if err != nil {
		return resp, "", "", "", err
	}
	defer resp.Body.Close()

	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		logger.Println("Error with ", url, "when retrieving body. ", err)
	}

	if len(bytes) > 1 {
		tmpSlice := strings.Split(string(bytes), "<title>")
		if len(tmpSlice) > 1 {
			title = strings.Split(tmpSlice[1], "</title>")[0]
		}
	}

	if resp.StatusCode >= 300 || resp.StatusCode <= 310 {
		redirect = resp.Header.Get("Location")
	}

	fmt.Println(resp.Header)
	// Authorisation
	for name, value := range resp.Header {
		if strings.ToLower(name) == "www-authenticate" || strings.ToLower(name) == "proxy-authenticate" {
			authentication = authentication + strings.Join(value, " ")
		}
	}

	return resp, title, redirect, authentication, nil
}
